import React from 'react';
import './App.css';

// this is the array that maps each pattern (bitmask) to a tile position (from tileset, starting at upper-left).
// see tileRegion's comment on TileImg function for better details.
const autoTilerMap = new Array(16).fill([0, 0]);

// the order that I added the entries below is from the tileset, up to bottom, left to right.
// first line of tileset
// see the mentioned comments, 0-bit represents the up neighbor tile, 1 is left, 2 is right, 3 is down.
//             b3210    x  y
autoTilerMap[0b0000] = [0, 0];
autoTilerMap[0b0100] = [1, 0];
autoTilerMap[0b0110] = [2, 0];
autoTilerMap[0b0010] = [3, 0];

// second line of tileset
//             b3210    x  y
autoTilerMap[0b1000] = [0, 1];
autoTilerMap[0b1100] = [1, 1];
autoTilerMap[0b1110] = [2, 1];
autoTilerMap[0b1010] = [3, 1];

// third line of tileset
//             b3210    x  y
autoTilerMap[0b1001] = [0, 2];
autoTilerMap[0b1101] = [1, 2];
autoTilerMap[0b1111] = [2, 2];
autoTilerMap[0b1011] = [3, 2];

// fourth line of tileset
//             b3210    x  y
autoTilerMap[0b0001] = [0, 3];
autoTilerMap[0b0101] = [1, 3];
autoTilerMap[0b0111] = [2, 3];
autoTilerMap[0b0011] = [3, 3];


// TileImg is renders a tile, this is used to mount the tilemap preview.
function TileImg(props) {
  // tileRegion is a bitset generated by genTileRegion method of TileEditor class.
  // Each bit from the bitset marks the presence of existent or inexistent neighbor tiles:
  //
  // neighbor tile positions (center is ignored):
  // [ ][0][ ]
  // [1][ ][2]
  // [ ][3][ ]
  //
  // corresponding bitset: 0b3210
  //
  // Each combination of neighbor tiles will have one different number (more precisely, one bitmask),
  // which also corresponds to specific tile, this is how auto-tiling works :) (see website for better
  // explanation).
  //
  // That said, the `autoTilerMap` variable maps each tileRegion combination with an array, this array
  // contains two entries, which is tileX and tileY, which is the position of the right tile at the tileset.
  let tileRegion = props.tileRegion

  // get's the tile unit position from tileset that matches the pattern bitset.
  let [tileX, tileY] = autoTilerMap[tileRegion];

  // then calcuate pixel position
  const x = -18 * tileX;
  const y = -18 * tileY;

  // create an inline style to apply to this tile, note that it may be not used if the tile is
  // "inexistent" (this data is stored on props.isActive)
  const inline_style = {
    backgroundImage: "url('tileset.png')",
    backgroundPosition: `${x}px ${y}px`,
  };

  // render the tile as a div, note that the style declared above is not used if the tile is inexistent
  return (
    <div className="tileImg" style={props.isActive ? inline_style : {}}>
    </div>
  );
}

// The tile button component, this is the tile you click on the webpage to toggle the existence of
// a tile on tilemap editor.
function TileButton(props) {
  return (
    <button className={"tile_button" + (props.isActive ? " active_tile" : "") } onClick={() => props.onClick(props.tileIndex)}>
      {props.tileIndex}
    </button>
  );
}

// Tile map editor, but also preview
class TileEditor extends React.Component {
  // this class is constructed with a state, this state contains the tilemap's actual map, which
  // is an array of booleans.
  constructor(props) {
    super(props);

    this.state = {
      // the map, is an array of 50 tiles, in other implementations is more likely declared
      // as a matrix I guess, but here I used just an array.
      map: Array(50).fill(false),
    };

    this.handleClick = this.handleClick.bind(this);
    this.genTileRegion = this.genTileRegion.bind(this);
  }

  genTileRegion(i) {
    let map = this.state.map;

    // This is where the pattern is actually made,
    // [   0,
    //  1,    2,
    //     3   ],
    let arrTileRegion = Array(4).fill(false);

    arrTileRegion[0] = i - 10 >= 0 ? map[i - 10] : false;
    arrTileRegion[1] = i -  1 >= 0 ? map[i -  1] : false;

    arrTileRegion[2] = i +  1 < map.length ? map[i +  1] : false;
    arrTileRegion[3] = i + 10 < map.length ? map[i + 10] : false;

    // handle map boundaries]
    switch (i % 10) {
      case 0: arrTileRegion[1] = false; break; // left boundary, overwrite left tile as "no-tile"
      case 9: arrTileRegion[2] = false; break; // right boundary, overwrite right tile as "no-tile"
    }

    let tileRegion = 0;

    // then, convert the array (matrix) to a bitset: 0b3210
    for (let x = 0; x < 4; x++)
      tileRegion = tileRegion | ((arrTileRegion[x] ? 1 : 0) << x);

    return tileRegion;
  }

  handleClick(tileIndex) {
    let map = this.state.map.slice();
    map[tileIndex] = !map[tileIndex];
    this.setState({map: map})
  }

  render() {
    let tileEditorButtons = [];
    let tileMapTiles = [];

    let map = this.state.map;
    for (let i = 0; i < 50; i++) {
      let curTile = map[i];

      let tileRegion = this.genTileRegion(i);

      tileEditorButtons.push(<TileButton tileIndex={i} onClick={this.handleClick} isActive={curTile} key={i} />);

      tileMapTiles.push(<TileImg key={i} isActive={curTile} tileRegion={tileRegion} tileIndex={i} />);

      if (i % 10 === 9) {
        tileEditorButtons.push(<br key={i + "_TE_br"}/>);
        tileMapTiles.push(<br key={i + "_TM_br"}/>);
      }
    }

    return (
      <div id="tile_editor">
        <div className="tile_editor_pannel">
          <div id="tile_editor_buttons">
            {tileEditorButtons}
          </div>
        </div>
        <div className="tile_editor_pannel">
          <div id="tile_editor_preview">
            {tileMapTiles}
          </div>
        </div>
      </div>
    );
  }
}

function App() {
  return (
    <div className="App">
      <main>
        <h1>Autotiler toy<br/>simple autotiling and React experiment</h1>
        <p>
          Made by <a href="https://github.com/Andre-LA/">Andr√© Luiz Alvares</a><br/>
          see <a href="https://github.com/Andre-LA/my-autotiler-toy">source code</a>.<br/>
          <a href="https://www.kenney.nl/assets/pixel-platformer">Tileset made by Kenney</a>.
        </p>
        <TileEditor />
      </main>
    </div>
  );
}

export default App;
