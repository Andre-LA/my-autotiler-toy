import React from 'react';
import './App.css';

// this is the array that maps each pattern (bitmask) to a tile position (from tileset, starting at upper-left).
// see tileRegion's comment on TileImg function for better details.
const autoTilerMap = new Array(16).fill([0, 0]);

// the order that I added the entries below is from the tileset, up to bottom, left to right.
// first line of tileset
// see the mentioned comments, 0-bit represents the up neighbor tile, 1 is left, 2 is right, 3 is down.
//             b3210    x  y
autoTilerMap[0b0000] = [0, 0];
autoTilerMap[0b0100] = [1, 0];
autoTilerMap[0b0110] = [2, 0];
autoTilerMap[0b0010] = [3, 0];

// second line of tileset
//             b3210    x  y
autoTilerMap[0b1000] = [0, 1];
autoTilerMap[0b1100] = [1, 1];
autoTilerMap[0b1110] = [2, 1];
autoTilerMap[0b1010] = [3, 1];

// third line of tileset
//             b3210    x  y
autoTilerMap[0b1001] = [0, 2];
autoTilerMap[0b1101] = [1, 2];
autoTilerMap[0b1111] = [2, 2];
autoTilerMap[0b1011] = [3, 2];

// fourth line of tileset
//             b3210    x  y
autoTilerMap[0b0001] = [0, 3];
autoTilerMap[0b0101] = [1, 3];
autoTilerMap[0b0111] = [2, 3];
autoTilerMap[0b0011] = [3, 3];


// TileImg is renders a tile, this is used to mount the tilemap preview.
function TileImg(props) {
  // tileRegion is a bitset generated by genTileRegion method of TileEditor class.
  // Each bit from the bitset marks the presence of existent or inexistent neighbor tiles:
  //
  // neighbor tile positions (center is ignored):
  // [ ][0][ ]
  // [1][ ][2]
  // [ ][3][ ]
  //
  // corresponding bitset: 0b3210
  //
  // Each combination of neighbor tiles will have one different number (more precisely, one bitmask),
  // which also corresponds to specific tile, this is how auto-tiling works :) (see website for better
  // explanation).
  //
  // That said, the `autoTilerMap` variable maps each tileRegion combination with an array, this array
  // contains two entries, which is tileX and tileY, which is the position of the right tile at the tileset.
  let tileRegion = props.tileRegion

  // get's the tile unit position from tileset that matches the pattern bitset.
  let [tileX, tileY] = autoTilerMap[tileRegion];

  // then calcuate pixel position
  const x = -18 * tileX;
  const y = -18 * tileY;

  // create an inline style to apply to this tile, note that it may be not used if the tile is
  // "inexistent" (this data is stored on props.isActive)
  const inline_style = {
    backgroundImage: "url('tileset.png')",
    backgroundPosition: `${x}px ${y}px`,
  };

  // render the tile as a div, note that the style declared above is not used if the tile is inexistent
  return (
    <div className="tileImg" style={props.isActive ? inline_style : {}}>
    </div>
  );
}

// The tile button component, this is the tile you click on the webpage to toggle the existence of
// a tile on tilemap editor.
function TileButton(props) {
  return (
    <button className={"tile_button" + (props.isActive ? " active_tile" : "") } onClick={() => props.onClick(props.tileIndex)}>
      {props.tileIndex}
    </button>
  );
}

// Tile map editor, but also preview
class TileEditor extends React.Component {
  // this class is constructed with a state, this state contains the tilemap's actual map, which
  // is an array of booleans.
  constructor(props) {
    super(props);

    this.state = {
      // the map, is an array of 50 tiles, in other implementations is more likely declared
      // as a matrix I guess, but here I used just an array.
      map: Array(50).fill(false),
    };

    this.handleClick = this.handleClick.bind(this);
    this.genTileRegion = this.genTileRegion.bind(this);
  }

  genTileRegion(i) {
    let map = this.state.map;

    // This is where the pattern is actually made,
    // [   0,
    //  1,    2,
    //     3   ],
    let arrTileRegion = Array(4).fill(false);

    arrTileRegion[0] = i - 10 >= 0 ? map[i - 10] : false;
    arrTileRegion[1] = i -  1 >= 0 ? map[i -  1] : false;

    arrTileRegion[2] = i +  1 < map.length ? map[i +  1] : false;
    arrTileRegion[3] = i + 10 < map.length ? map[i + 10] : false;

    // handle map boundaries]
    switch (i % 10) {
      case 0: arrTileRegion[1] = false; break; // left boundary, overwrite left tile as "no-tile"
      case 9: arrTileRegion[2] = false; break; // right boundary, overwrite right tile as "no-tile"
    }

    let tileRegion = 0;

    // then, convert the array (matrix) to a bitset: 0b3210
    for (let x = 0; x < 4; x++)
      tileRegion = tileRegion | ((arrTileRegion[x] ? 1 : 0) << x);

    return tileRegion;
  }

  handleClick(tileIndex) {
    let map = this.state.map.slice();
    map[tileIndex] = !map[tileIndex];
    this.setState({map: map})
  }

  render() {
    let tileEditorButtons = [];
    let tileMapTiles = [];

    let map = this.state.map;
    for (let i = 0; i < 50; i++) {
      let curTile = map[i];

      let tileRegion = this.genTileRegion(i);

      tileEditorButtons.push(<TileButton tileIndex={i} onClick={this.handleClick} isActive={curTile} key={i} />);

      tileMapTiles.push(<TileImg key={i} isActive={curTile} tileRegion={tileRegion} tileIndex={i} />);

      if (i % 10 === 9) {
        tileEditorButtons.push(<br key={i + "_TE_br"}/>);
        tileMapTiles.push(<br key={i + "_TM_br"}/>);
      }
    }

    return (
      <article id="tile_editor">
        <h2>Tilemap Editor and Preview</h2>
        <div className="tile_editor_pannel">
          <div id="tile_editor_buttons">
            {tileEditorButtons}
          </div>
        </div>
        <div className="tile_editor_pannel">
          <div id="tile_editor_preview">
            {tileMapTiles}
          </div>
        </div>
      </article>
    );
  }
}

function Header() {
  return (
    <article>
      <h1>Autotiler toy<br/>simple autotiling and React experiment</h1>
      <p>
        Made by <a href="https://github.com/Andre-LA/">Andr√© Luiz Alvares</a><br/>
        see <a href="https://github.com/Andre-LA/my-autotiler-toy">source code</a>.<br/>
        <a href="https://www.kenney.nl/assets/pixel-platformer">Tileset made by Kenney</a>.
      </p>
    </article>
  )
}

function Article() {
  return (
    <article id="impl-details">
      <h2>Explica√ß√£o da implementa√ß√£o</h2>

      <p><em>Note: This article is for now written in portuguese, it will soon be translated to english </em>üòâ</p>

      <section>
        <h3>O que √© um Tilemap e Autotiling?</h3>

        <p>
          H√° v√°rias formas de se construir um cen√°rio de um jogo, e uma das mais cl√°ssicas √©
          atrav√©s dos chamados <em>Tilemaps</em>, que s√£o a constru√ß√£o de um cen√°rio atrav√©s de pequenas
          pe√ßas chamadas de <em>tiles</em>, essas tiles s√£o usadas a partir de um conjunto dessas pe√ßas,
          chamado de <em>tileset</em>.
        </p>

        <p>
          Por exemplo, um tilemap de praia simples poderia ser criada a partir de um tileset de
          apenas tr√™s tiles (mar, areia e espraiamento).
        </p>

        <p>
          Entretanto, todo tilemap mais enxuto cont√©m diversas tiles que se conectam e
          precisam <strong>respeitar um certo padr√£o</strong>, usando o exemplo do editor acima,
          num jogo 2D lateral onde temos uma tile de terra e outra tamb√©m de terra, mas com sua
          superf√≠cie coberta de neve, essa tile com neve s√≥ poderia ser utilizada se ela for
          uma superf√≠cie, ou seja, n√£o h√° tiles em cima dela.
        </p>

        <p>
          Ou seja, existe a necessidade de colocar tiles espec√≠ficos adequadamente, e este processo,
          se feito de forma completamente manual, pode ser bem entediante e consumir muito tempo, al√©m
          de ser sucet√≠vel a erros. Felizmente h√° algumas t√©cnicas para automatizar esse processo,
          e por isso s√£o chamadas de <em>autotiling</em>.
        </p>
      </section>

      <section>
        <h3>Como funciona um Autotiler de forma geral</h3>

        <p>
          Existem diferentes implementa√ß√µes de autotiling, algumas simples como a desta p√°gina,
          e <a href="https://twitter.com/x_rxi/status/1276576637333770244">outras mais complexas</a>.
        </p>

        <p>
          Autotilers mais complexos te permite maiores possibilidades de automatiza√ß√£o para tilemaps
          complexos, entretanto, para tilemaps simples essa complexidade pode tamb√©m n√£o compensar,
          ent√£o sempre depende do seu caso espec√≠fico.
        </p>

        <p>
          Apesar das diferen√ßas entre as implementa√ß√µes, a maioria (pra n√£o dizer todas) se baseiam
          no mesmo princ√≠pio, que √© associar as tiles de uma tileset com padr√µes, tamb√©m chamada de
          regras em algumas implementa√ß√µes.
        </p>

        <p>
          Um padr√£o (ou regra) por si s√≥ √© um dado que guarda a exist√™ncia ou inexist√™ncia de tiles
          adjacentes √† tile correspondente ao padr√£o, entretanto ele n√£o √© mut√°vel e n√£o guarda
          "se h√° uma tile adjacente" em tempo de execu√ß√£o do jogo, ele apenas guarda a exist√™ncia
          e inexist√™ncia de tiles adjacentes, como se fosse um tipo de c√≥digo ou identifica√ß√£o.
        </p>

        <p>
          Esse padr√£o √© utilizado para indicar quando uma certa tile dever√° ser aplicada pelo
          autotiler, usando exemplo anterior, uma tile coberta de neve s√≥ poderia ser
          utilizada se n√£o houver uma tile adjacente em cima; sendo assim, o padr√£o dessa tile
          √© a de que n√£o dever√° existir uma tile adjacente acima.
        </p>

        <p>
          Sendo assim, o que um <em>autotiler</em> b√°sico faz √© receber um tilemap simples que
          simplesmente indica a exist√™ncia ou n√£o de tiles, e ent√£o √© convertido para um tilemap
          mais complexo a partir da correspond√™ncias de cada tile com sua combina√ß√£o de adjac√™ncias.
        </p>

        <p>
          Como dito anteriormente, essa √© uma premissa geral, como um autotiler realmente funciona
          de forma mais detalhada depende da implementa√ß√£o, dois exemplos s√£o os
          softwares <a href="https://ldtk.io/">LDtk</a> e <a href="https://rxi.itch.io/tilekit">Tilekit</a>,
          que s√£o ferramentas de cria√ß√£o de tilemaps com a funcionalidade de autotiling.
        </p>
      </section>

      <section>
        <h3>Implementa√ß√£o deste autotiller</h3>

        <p>
          Essa se√ß√£o abordar√° da implementa√ß√£o espec√≠fica utilizada no editor acima, √© recomend√°vel
          a leitura de outras fontes (citadas abaixo) para um entendimento melhor, mais abrangente
          e com maiores horizontes, entretanto n√£o √© interesse desse artigo explicar a implementa√ß√£o
          linha por linha, para isso, recomendo
          a <a href="https://github.com/Andre-LA/my-autotiler-toy/blob/main/src/App.js">
            leitura do c√≥digo fonte
          </a> diretamente, que est√° documentada de forma mais espec√≠fica.
        </p>

        <p>
          Como dito anteriormente, um autotiler obt√©m como entrada um "tilemap booliano" e um
          conjunto de padr√µes (ou regras) associados √†s tiles de um tileset.
        </p>

        <p>
          Com isso, ele consegue corresponder cada tile do tilemap com um dos padr√µes de acordo
          com as tiles adjacentes √† tile do tilemap, isto resulta numa tile do tileset, que
          ent√£o ser√° aplicada na posi√ß√£o da tile do tilemap, no final do processo um novo tilemap
          ser√° criado e finalmente retornado.
        </p>

        <p>
          O padr√£o em si √© representado por
          um <a href="https://en.wikipedia.org/wiki/Bit_array">bitset</a> (tamb√©m chamado de bitmask),
          enquanto que o tilemap, no caso desta implementa√ß√£o, √© inicialmente um arranjo de boolianas
          e ao final do processo de autotiling se torna um arranjo de coordenadas (que se referem a posi√ß√£o
          dos tile vindos do tileset).
        </p>

        <p>
          Observa√ß√£o do Autor: Na verdade o autotiler n√£o est√° retornando um arranjo de coordenadas, e sim
          criando os tiles diretamente porque o autotiler est√° aplicado nas tiles e n√£o como uma fun√ß√£o
          separada, eu preciso corrigir isto, pois acredito que modularizar esse processo numa fun√ß√£o
          tornar√° a implementa√ß√£o mais adequada.
        </p>
      </section>
    </article>
  )
}

function App() {
  return (
    <div className="App">
      <main>
        <Header />

        <TileEditor />

        <Article />
      </main>
    </div>
  );
}

export default App;
